Nyan
hemni276 julma873


Nyan är ett imperativt språk. Språket ska inspireras av katter och ljuden 
de gör, exempel på koden kan se ut som följande:

mao ^While_print^:								//function
    prrr ^i < 0^:								//while-loop
     	meow ^"utskrift"^						//print
     	?nya? ^i < 0^:							//if-statement
			meow ^"youve been meowed"^			//print
		:3										//end
	:3											//end
:3												//end
				
Funktionaliteten ska likna python på vissa sätt, speciellt när man passerar 
variabler in i en funktion, då de kommer agera som referenser. En skillnad är att
vi planerar att ha statisk typning så att vi kan använda kattansikten för att 
deklarera typer. Hur dessa ansikten används beskrivs här: 

^w^ "hello"		//str
^3^ 42 			//int
^.^ 3.14 		//float
^oo^ false 		//bool

list=[]

Scope:

Vi väljer att använda ett statiskt scope. Med detta vill vi säga att variablers 
definitioner är baserade på vilket scope som funktionen ankallades i. 

BNF grammatik:

<program>::= <component> 

<component>::= <component> <component> | <function> | <block>

<function>::= "mao" <variable> "^" <params> "^" <stmts>

<function_call>::= <variable> <params>

<stmts>::= ":" <block> ":3"

<block>::= <assignment> | <blocks> | <condition> | <while> | <return> | <arithmatic> | <print>

<return>::= "return" 

<assignment>::= <datatype> <variable> "=" <value>

<print>::= "meow" "^" <value> "^"

<blocks>::= <blocks> <block> | <block>

<params>::= <params> "," <datatype> <variable> |
			<datatype> <variable>

<variable>::= /[[:alpha:]\d_]+/

<value> ::= <int> | <str> | <float> | <bool> | <arithmatic>

<int>::= /\d+/

<str>::= '"' /[^"]/ '"'

<float>::= /[\d]+\.[\d]+/

<bool>::= "True" | "False"

<condition>::= "?nye?" "^" <logic_stmt> "^"  <condition_followup> 
			   
<condition_followup>::= <stmts> |
						<block> "?nyanye?" <condition_followup> |
						<block> "?nye?" <stmt> 

<logic_stmt>::= not <logic_stmt> |
				<logic_stmt> and <logic_stmt> |
				<logic_stmt> or <logic_stmt>  |
				<comparison_stmt> | <logic_expr>

<comparison_stmt> ::= <equal_op> | <value_comp>

<equal_op> ::= <logic_stmt> '==' <logic_stmt> |
			   <logic_stmt> '!=' <logic_stmt>

<value_comp> ::= <logic_stmt> < <logic_stmt>  |
				 <logic_stmt> > <logic_stmt>  |
				 <logic_stmt> <= <logic_stmt> |
				 <logic_stmt> >= <logic_stmt> |

<logic_expr> ::= <variable> | <value>
				    
<term>::= <expr> | <expr> <operator_lo> <expr>

<expr>::= <factor> | <factor> <operator_hi> <factor>

<factor>::= "(" <term> ")" | <int> | <variable>

<operator_lo>::= '+' | '-'

<operator_hi>::= '*' | '/' 

<while>::= "prrr" "^" <logic_stmt> "^" <stmts>

<datatype>::= "^w^"  |
		   	  "^3^"  |
		      "^.^"  |
		      "^oo^" |